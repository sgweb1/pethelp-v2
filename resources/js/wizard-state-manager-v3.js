/**
 * Pet Sitter Wizard - Centralized State Manager v3.0
 *
 * Implementuje wzorzec "Single Source of Truth" (SSOT) dla kompletnego
 * zarzƒÖdzania stanem wizard'a rejestracji pet sittera.
 *
 * ZALETY ARCHITEKTURY V3:
 * - Jeden centralny state - koniec z duplikacjƒÖ zmiennych
 * - Automatyczna synchronizacja miƒôdzy krokami
 * - Reactive updates wszystkich komponent√≥w
 * - Zintegrowane debugging i development tools
 * - Pe≈Çna kompatybilno≈õƒá z Livewire
 *
 * @author Claude AI Assistant
 * @version 3.0.0
 * @since 2025-09-29
 */

class WizardStateManager {
    constructor() {
        /**
         * Centralny state - SINGLE SOURCE OF TRUTH
         * Wszystkie dane wizard'a sƒÖ przechowywane tutaj.
         */
        this.state = {
            // Meta informacje o wizard'ie
            meta: {
                currentStep: 1,
                maxSteps: 12,
                isActive: false,
                progressPercentage: 0,
                completionPercentage: 0,
                completedSteps: [],
                isValid: false,
                canProceed: false
            },

            // Krok 1: Dane osobowe i motywacja
            personalData: {
                name: '',
                email: '',
                city: '',
                motivation: '',
                motivationLength: 0,
                hasStartedTyping: false
            },

            // Krok 2-3: Do≈õwiadczenie z zwierzƒôtami
            experience: {
                petExperience: [], // Powinno byƒá array, nie string
                experienceDescription: '',
                yearsOfExperience: 0,
                animalTypes: [],
                animalSizes: [],
                hasExperienceWithDogs: false,
                hasExperienceWithCats: false,
                hasExperienceWithSmallAnimals: false
            },

            // Krok 4: Typy us≈Çug
            services: {
                serviceTypes: [],
                specialServices: [],
                canWalkDogs: false,
                canOvernightSit: false,
                canDaySit: false,
                canPetGrooming: false
            },

            // Krok 5: Adres i obszar dzia≈Çania
            location: {
                address: '',
                serviceRadius: 10,
                coordinates: {
                    lat: null,
                    lng: null
                }
            },

            // Krok 6: Dostƒôpno≈õƒá czasowa
            availability: {
                weeklyAvailability: {},
                flexibleSchedule: false,
                emergencyAvailable: false,
                morningAvailable: false,
                afternoonAvailable: false,
                eveningAvailable: false,
                weekendAvailable: false
            },

            // Krok 7: Informacje o domu
            home: {
                homeType: '',
                hasGarden: false,
                isSmoking: false,
                hasOtherPets: false,
                otherPets: [],
                isSafeEnvironment: true,
                hasSecureFencing: false
            },

            // Krok 8-9: Weryfikacja to≈ºsamo≈õci i dokumenty
            verification: {
                hasProfilePhoto: false,
                homePhotosCount: 0,
                hasIdentityDocument: false,
                hasCriminalRecord: false,
                referencesCount: 0,
                isVerified: false
            },

            // Krok 10: Cennik
            pricing: {
                pricingStrategy: 'competitive', // competitive, premium, budget
                servicePricing: {
                    dogWalking: 0,
                    overnightSitting: 0,
                    daySitting: 0,
                    petGrooming: 0
                }
            },

            // Krok 11-12: Warunki i finalizacja
            terms: {
                agreedToTerms: false,
                marketingConsent: false,
                privacyPolicyAccepted: false,
                completedAt: null
            }
        };

        /**
         * Obserwatorzy zmian stanu
         * @type {Function[]}
         */
        this.watchers = [];

        /**
         * Referencja do instancji Livewire
         * @type {Object|null}
         */
        this.livewire = null;

        /**
         * Tryb debugowania - w≈ÇƒÖczony w development
         * @type {boolean}
         */
        this.debugging = process.env.NODE_ENV === 'development' || window.location.hostname === 'pethelp.test';

        /**
         * Historia zmian dla debugowania
         * @type {Array}
         */
        this.changeHistory = [];

        /**
         * Maksymalna liczba zapisywanych zmian w historii
         * @type {number}
         */
        this.maxHistorySize = 100;

        // Inicjalizacja
        this.init();
    }

    /**
     * Inicjalizuje state manager.
     *
     * @returns {void}
     */
    init() {
        if (this.debugging) {
            console.log('üèóÔ∏è WizardStateManager v3.0 INITIALIZED');
            console.log('üìä Initial state:', this.state);
        }

        // Globalna dostƒôpno≈õƒá
        window.WizardState = this;

        // Event listener dla Livewire
        this.setupLivewireIntegration();

        // Development helpers
        this.setupDevHelpers();
    }

    /**
     * Aktualizuje warto≈õƒá w state u≈ºywajƒÖc ≈õcie≈ºki dot notation.
     *
     * @param {string} path - ≈öcie≈ºka do w≈Ça≈õciwo≈õci (np. 'home.hasGarden')
     * @param {*} value - Nowa warto≈õƒá
     * @returns {void}
     */
    update(path, value) {
        const oldValue = this.get(path);

        // Sprawd≈∫ czy warto≈õƒá faktycznie siƒô zmieni≈Ça
        if (oldValue === value) {
            return;
        }

        this.set(path, value);

        // Zapisz zmianƒô w historii
        this.recordChange(path, oldValue, value);

        // Auto-sync z Livewire
        this.syncToLivewire(path, value);

        // Powiadom obserwator√≥w
        this.notify(path, value, oldValue);

        // Debug log
        if (this.debugging) {
            console.log(`üîÑ State updated: ${path}`, {
                old: oldValue,
                new: value,
                timestamp: new Date().toISOString()
            });
        }
    }

    /**
     * Pobiera warto≈õƒá z state u≈ºywajƒÖc ≈õcie≈ºki dot notation.
     *
     * @param {string} path - ≈öcie≈ºka do w≈Ça≈õciwo≈õci
     * @returns {*} Warto≈õƒá lub undefined je≈õli nie istnieje
     */
    get(path) {
        return path.split('.').reduce((obj, key) => obj?.[key], this.state);
    }

    /**
     * Ustawia warto≈õƒá w state u≈ºywajƒÖc ≈õcie≈ºki dot notation.
     *
     * @param {string} path - ≈öcie≈ºka do w≈Ça≈õciwo≈õci
     * @param {*} value - Warto≈õƒá do ustawienia
     * @returns {void}
     */
    set(path, value) {
        const keys = path.split('.');
        const lastKey = keys.pop();
        const target = keys.reduce((obj, key) => {
            if (!obj[key]) obj[key] = {};
            return obj[key];
        }, this.state);

        target[lastKey] = value;

        // Aktualizuj meta informacje
        this.updateMetaState();
    }

    /**
     * Aktualizuje meta informacje o wizard'ie.
     *
     * @returns {void}
     */
    updateMetaState() {
        // Oblicz progress
        const totalSteps = this.state.meta.maxSteps;
        const currentStep = this.state.meta.currentStep;
        this.state.meta.progressPercentage = Math.round((currentStep / totalSteps) * 100);

        // Sprawd≈∫ czy current step jest uko≈Ñczony
        const stepValidation = this.validateCurrentStep();
        this.state.meta.canProceed = stepValidation.isValid;
        this.state.meta.isValid = stepValidation.isValid;
    }

    /**
     * Waliduje aktualny krok.
     *
     * @returns {Object} Wynik walidacji
     */
    validateCurrentStep() {
        const step = this.state.meta.currentStep;

        switch (step) {
            case 1:
                return {
                    isValid: this.state.personalData.motivation.length >= 50,
                    errors: this.state.personalData.motivation.length < 50 ? ['Motywacja musi mieƒá co najmniej 50 znak√≥w'] : []
                };

            case 2:
                return {
                    isValid: this.state.experience.petExperience.length > 0 && this.state.experience.animalTypes.length > 0,
                    errors: []
                };

            case 3:
                return {
                    isValid: this.state.experience.yearsOfExperience > 0,
                    errors: []
                };

            case 4:
                return {
                    isValid: this.state.services.serviceTypes.length > 0,
                    errors: []
                };

            case 6:
                return {
                    isValid: Object.keys(this.state.availability.weeklyAvailability).length > 0,
                    errors: []
                };

            case 7:
                return {
                    isValid: this.state.home.homeType.length > 0,
                    errors: []
                };

            default:
                return { isValid: true, errors: [] };
        }
    }

    /**
     * Synchronizuje dane z komponentem Livewire.
     *
     * @param {string} path - ≈öcie≈ºka do w≈Ça≈õciwo≈õci
     * @param {*} value - Warto≈õƒá do synchronizacji
     * @returns {void}
     */
    syncToLivewire(path, value) {
        if (!this.livewire) {
            // Spr√≥buj znale≈∫ƒá instancjƒô Livewire
            const wizardElement = document.querySelector('[wire\\:id]');
            if (wizardElement && window.Livewire) {
                this.livewire = window.Livewire.find(wizardElement.getAttribute('wire:id'));
            }
        }

        if (this.livewire && this.livewire.set) {
            try {
                // Mapuj ≈õcie≈ºkƒô z state na w≈Ça≈õciwo≈õƒá Livewire
                const livewireProperty = this.mapPathToLivewire(path);
                if (livewireProperty) {
                    this.livewire.set(livewireProperty, value, false);

                    if (this.debugging) {
                        console.log(`üîó Synced to Livewire: ${livewireProperty} = ${value}`);
                    }
                }
            } catch (error) {
                console.error('‚ùå Livewire sync error:', error);
            }
        }
    }

    /**
     * Mapuje ≈õcie≈ºkƒô state na w≈Ça≈õciwo≈õƒá Livewire.
     *
     * @param {string} path - ≈öcie≈ºka w state
     * @returns {string|null} W≈Ça≈õciwo≈õƒá Livewire lub null
     */
    mapPathToLivewire(path) {
        // Mapowanie ≈õcie≈ºek z centralnego state na w≈Ça≈õciwo≈õci Livewire
        const mapping = {
            'personalData.motivation': 'motivation',
            'personalData.name': 'name',
            'personalData.email': 'email',
            'personalData.city': 'city',
            'experience.petExperience': 'petExperience',
            'experience.animalTypes': 'animalTypes',
            'experience.animalSizes': 'animalSizes',
            'services.serviceTypes': 'serviceTypes',
            'location.address': 'address',
            'location.serviceRadius': 'serviceRadius',
            'availability.flexibleSchedule': 'flexibleSchedule',
            'availability.emergencyAvailable': 'emergencyAvailable',
            'home.homeType': 'homeType',
            'home.hasGarden': 'hasGarden',
            'home.isSmoking': 'isSmoking',
            'home.hasOtherPets': 'hasOtherPets',
            'meta.currentStep': 'currentStep'
        };

        return mapping[path] || null;
    }

    /**
     * Dodaje obserwatora zmian stanu.
     *
     * @param {Function} callback - Funkcja wywo≈Çana przy zmianie
     * @returns {void}
     */
    watch(callback) {
        if (typeof callback === 'function') {
            this.watchers.push(callback);
        }
    }

    /**
     * Powiadamia wszystkich obserwator√≥w o zmianie.
     *
     * @param {string} path - ≈öcie≈ºka do zmienionej w≈Ça≈õciwo≈õci
     * @param {*} newValue - Nowa warto≈õƒá
     * @param {*} oldValue - Stara warto≈õƒá
     * @returns {void}
     */
    notify(path, newValue, oldValue) {
        this.watchers.forEach(callback => {
            try {
                callback(path, newValue, oldValue);
            } catch (error) {
                console.error('‚ùå Watcher error:', error);
            }
        });
    }

    /**
     * Zapisuje zmianƒô w historii dla debugowania.
     *
     * @param {string} path - ≈öcie≈ºka do w≈Ça≈õciwo≈õci
     * @param {*} oldValue - Stara warto≈õƒá
     * @param {*} newValue - Nowa warto≈õƒá
     * @returns {void}
     */
    recordChange(path, oldValue, newValue) {
        this.changeHistory.push({
            timestamp: new Date().toISOString(),
            path,
            oldValue,
            newValue,
            stack: new Error().stack
        });

        // Ogranicz rozmiar historii
        if (this.changeHistory.length > this.maxHistorySize) {
            this.changeHistory.shift();
        }
    }

    /**
     * Konfiguruje integracjƒô z Livewire.
     *
     * @returns {void}
     */
    setupLivewireIntegration() {
        if (typeof window !== 'undefined') {
            // Nas≈Çuchuj event Livewire loaded
            document.addEventListener('livewire:initialized', () => {
                if (this.debugging) {
                    console.log('üîó Livewire integration initialized');
                }
            });

            // Nas≈Çuchuj navigacjƒô
            document.addEventListener('livewire:navigated', () => {
                this.livewire = null; // Reset referencji
            });
        }
    }

    /**
     * Konfiguruje development helpers.
     *
     * @returns {void}
     */
    setupDevHelpers() {
        if (this.debugging && typeof window !== 'undefined') {
            // Globalne helpery dla developera
            window.dumpWizardState = () => {
                console.table(this.state);
                return this.state;
            };

            window.wizardHistory = () => {
                console.table(this.changeHistory);
                return this.changeHistory;
            };

            window.validateWizardStep = (step) => {
                const originalStep = this.state.meta.currentStep;
                this.state.meta.currentStep = step || originalStep;
                const result = this.validateCurrentStep();
                this.state.meta.currentStep = originalStep;
                console.log(`‚úÖ Step ${step || originalStep} validation:`, result);
                return result;
            };

            window.resetWizardState = () => {
                console.log('üîÑ Resetting wizard state...');
                this.state = new WizardStateManager().state;
                console.log('‚úÖ State reset complete');
            };

            // Console info
            console.log(`
üßô‚Äç‚ôÇÔ∏è WizardStateManager v3.0 Development Mode

Available commands:
‚Ä¢ dumpWizardState() - Shows current state
‚Ä¢ wizardHistory() - Shows change history
‚Ä¢ validateWizardStep(step) - Validates specific step
‚Ä¢ resetWizardState() - Resets state to initial
‚Ä¢ window.WizardState.update(path, value) - Updates state
‚Ä¢ window.WizardState.get(path) - Gets state value

Example usage:
WizardState.update('home.hasGarden', true)
WizardState.get('personalData.motivation')
            `);
        }
    }

    /**
     * Eksportuje kompletny state do JSON.
     *
     * @returns {string} JSON representation of state
     */
    exportState() {
        return JSON.stringify(this.state, null, 2);
    }

    /**
     * Importuje state z JSON.
     *
     * @param {string} jsonState - JSON state to import
     * @returns {boolean} Success status
     */
    importState(jsonState) {
        try {
            const imported = JSON.parse(jsonState);
            this.state = imported;
            this.updateMetaState();
            this.notify('*', this.state, {});
            return true;
        } catch (error) {
            console.error('‚ùå Import state error:', error);
            return false;
        }
    }

    /**
     * Resetuje state do warto≈õci poczƒÖtkowych.
     *
     * @returns {void}
     */
    reset() {
        const initialState = new WizardStateManager().state;
        this.state = initialState;
        this.changeHistory = [];
        this.notify('*', this.state, {});

        if (this.debugging) {
            console.log('üîÑ WizardStateManager reset to initial state');
        }
    }
}

// Inicjalizacja globalna - dostƒôpna wszƒôdzie w aplikacji
if (typeof window !== 'undefined') {
    // Stw√≥rz globalnƒÖ klasƒô
    window.WizardStateManager = WizardStateManager;

    // Automatyczna inicjalizacja gdy DOM jest gotowy - PRZYPISZ DO window.WizardState!
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', () => {
            window.WizardState = new WizardStateManager();
            console.log('‚úÖ WizardStateManager initialized on DOMContentLoaded');
        });
    } else {
        window.WizardState = new WizardStateManager();
        console.log('‚úÖ WizardStateManager initialized immediately');
    }
}

// Export dla modu≈Ç√≥w ES6
export default WizardStateManager;