<?php

namespace App\Services;

use App\Models\PopulationCoefficient;
use App\Models\PopulationGrid;
use Illuminate\Support\Facades\Cache;
use Illuminate\Support\Facades\Log;

/**
 * Serwis do estymacji populacji i potencjalnych klient√≥w.
 *
 * Wykorzystuje siatki populacyjne (gridy 1km¬≤) z Eurostat GEOSTAT
 * do precyzyjnego szacowania liczby potencjalnych klient√≥w w promieniu.
 *
 * Wersja 3.0 wprowadza zaawansowane wsp√≥≈Çczynniki korekcyjne uwzglƒôdniajƒÖce:
 * - Wielko≈õƒá miasta (kategorie X0-X4)
 * - Obecno≈õƒá uniwersytet√≥w (studenci)
 * - Ruch turystyczny
 * - Ruch dojazdowy do pracy
 * - Gƒôsto≈õƒá zabudowy
 *
 * @see POPULATION_ESTIMATION_COEFFICIENTS.md - pe≈Çna dokumentacja wsp√≥≈Çczynnik√≥w
 *
 * @author Claude AI Assistant
 *
 * @version 3.0.0
 */
class GUSApiService
{
    /**
     * Konstruktor serwisu.
     */
    public function __construct(
        private readonly LocationSearchService $locationService
    ) {}

    /**
     * Oblicza potencjalnƒÖ liczbƒô klient√≥w w danym obszarze.
     *
     * U≈ºywa siatek populacyjnych (1km¬≤) do dok≈Çadnego oszacowania populacji
     * w promieniu obs≈Çugi, niezale≈ºnie od granic administracyjnych.
     *
     * Wersja 3.0 - Formu≈Ça z wsp√≥≈Çczynnikami korekcyjnymi:
     * 1. Znajd≈∫ wszystkie kratki 1km¬≤ w promieniu
     * 2. Zsumuj populacjƒô we wszystkich kratkach (G)
     * 3. Wykryj kontekst lokalizacji (miasto, uniwersytet, turystyka)
     * 4. Pobierz wsp√≥≈Çczynniki korekcyjne z bazy danych
     * 5. Oblicz skorygowanƒÖ populacjƒô: adjusted = G √ó k_base √ó (1 + K_students + K_tourism + ...)
     * 6. Zastosuj wsp√≥≈Çczynniki ko≈Ñcowe:
     *    - 37% Polak√≥w ma zwierzƒôta domowe (dane GUS 2023)
     *    - 25% w≈Ça≈õcicieli zwierzƒÖt szuka profesjonalnej opieki minimum raz w roku
     *
     * @param  float  $latitude  Szeroko≈õƒá geograficzna
     * @param  float  $longitude  D≈Çugo≈õƒá geograficzna
     * @param  int  $radiusKm  Promie≈Ñ obs≈Çugi w kilometrach
     * @return int Szacowana liczba potencjalnych klient√≥w
     */
    public function estimatePotentialClients(float $latitude, float $longitude, int $radiusKm): int
    {
        try {
            Log::info('üîç Rozpoczƒôto estymacjƒô', [
                'latitude' => $latitude,
                'longitude' => $longitude,
                'radius_km' => $radiusKm,
            ]);

            // Znajd≈∫ wszystkie kratki w promieniu
            $grids = PopulationGrid::findInRadius($latitude, $longitude, $radiusKm);

            Log::info('üìä Znaleziono kratki', [
                'count' => $grids->count(),
            ]);

            if ($grids->isEmpty()) {
                Log::warning('‚ùå Brak danych gridowych, u≈ºyto fallback estymacji', [
                    'latitude' => $latitude,
                    'longitude' => $longitude,
                    'radius_km' => $radiusKm,
                ]);

                return $this->estimateByRadius($radiusKm);
            }

            // Zsumuj populacjƒô we wszystkich kratkach (G)
            $gridPopulation = PopulationGrid::totalPopulation($grids);

            // Wykryj kontekst lokalizacji (miasto, charakterystyki)
            $context = $this->detectCityContext($latitude, $longitude, $gridPopulation);

            // Pobierz wsp√≥≈Çczynniki korekcyjne na podstawie wielko≈õci miasta
            $correctedPopulation = $this->applyCorrectionCoefficients($gridPopulation, $context);

            // Wsp√≥≈Çczynniki ko≈Ñcowe:
            // - 37% Polak√≥w ma zwierzƒôta domowe (dane GUS 2023)
            // - 25% w≈Ça≈õcicieli zwierzƒÖt szuka profesjonalnej opieki minimum raz w roku
            $petOwnershipRate = 0.37;
            $careSeekingRate = 0.25;

            $potentialClients = $correctedPopulation * $petOwnershipRate * $careSeekingRate;

            Log::info('Estymacja potencjalnych klient√≥w (gridy populacyjne + wsp√≥≈Çczynniki)', [
                'latitude' => $latitude,
                'longitude' => $longitude,
                'radius_km' => $radiusKm,
                'grids_found' => $grids->count(),
                'grid_population' => $gridPopulation,
                'corrected_population' => round($correctedPopulation),
                'correction_factor' => round($correctedPopulation / max(1, $gridPopulation), 4),
                'city_category' => $context['category'] ?? 'unknown',
                'potential_clients' => round($potentialClients),
            ]);

            return max(50, round($potentialClients)); // Minimum 50 potencjalnych klient√≥w
        } catch (\Exception $e) {
            Log::error('B≈ÇƒÖd podczas estymacji z grid√≥w, u≈ºyto fallback', [
                'latitude' => $latitude,
                'longitude' => $longitude,
                'radius_km' => $radiusKm,
                'error' => $e->getMessage(),
            ]);

            return $this->estimateByRadius($radiusKm);
        }
    }

    /**
     * Wykrywa kontekst lokalizacji (miasto, charakterystyki).
     *
     * Analizuje lokalizacjƒô i zwraca informacje o charakterystykach miasta:
     * - Wielko≈õƒá (populacja w promieniu)
     * - Kategoria (X0-X4)
     * - Czy ma uniwersytet
     * - Czy jest miejscem turystycznym
     * - Czy jest centrum dojazdowym
     *
     * @param  float  $latitude  Szeroko≈õƒá geograficzna
     * @param  float  $longitude  D≈Çugo≈õƒá geograficzna
     * @param  int  $gridPopulation  Populacja z grid√≥w
     * @return array Kontekst lokalizacji
     */
    private function detectCityContext(float $latitude, float $longitude, int $gridPopulation): array
    {
        // Cache kontekstu na 24h (miasta rzadko zmieniajƒÖ charakterystyki)
        $cacheKey = "city_context:{$latitude}:{$longitude}";

        return Cache::remember($cacheKey, 86400, function () use ($latitude, $longitude, $gridPopulation) {
            $context = [
                'population' => $gridPopulation,
                'category' => $this->determineCityCategory($gridPopulation),
                'has_university' => false,
                'is_tourist_destination' => false,
                'is_commuter_hub' => false,
                'building_density_ratio' => 1.0,
            ];

            // Pobierz nazwƒô miasta z reverse geocoding
            $locationDetails = $this->locationService->getLocationDetails($latitude, $longitude);

            if ($locationDetails) {
                $cityName = mb_strtolower($locationDetails['city'] ?? '');

                // Wykryj uniwersytety (prosta heurystyka - mo≈ºna rozszerzyƒá o bazƒô danych)
                $context['has_university'] = $this->hasUniversity($cityName, $gridPopulation);

                // Wykryj miejsca turystyczne (mo≈ºna rozszerzyƒá o dane z API)
                $context['is_tourist_destination'] = $this->isTouristDestination($cityName);

                // Wykryj centra dojazdowe (du≈ºe miasta regionalne)
                $context['is_commuter_hub'] = $this->isCommuterHub($cityName, $gridPopulation);
            }

            Log::debug('Wykryto kontekst miasta', $context);

            return $context;
        });
    }

    /**
     * Okre≈õla kategoriƒô miasta na podstawie populacji.
     *
     * @param  int  $population  Populacja
     * @return string Kategoria (X0-X4)
     */
    private function determineCityCategory(int $population): string
    {
        if ($population < 5000) {
            return 'X0';
        } elseif ($population < 30000) {
            return 'X1';
        } elseif ($population < 100000) {
            return 'X2';
        } elseif ($population < 500000) {
            return 'X3';
        }

        return 'X4';
    }

    /**
     * Sprawdza czy miasto ma uniwersytet.
     *
     * Wykorzystuje rozszerzonƒÖ listƒô miast uniwersyteckich z pliku konfiguracyjnego
     * oraz heurystykƒô dla wiƒôkszych miast.
     *
     * @param  string  $cityName  Nazwa miasta
     * @param  int  $population  Populacja
     */
    private function hasUniversity(string $cityName, int $population): bool
    {
        // Pobierz listƒô miast uniwersyteckich z konfiguracji
        $universityCities = config('city_characteristics.university_cities', []);

        // Je≈õli miasto jest na li≈õcie uniwersyteckiej
        if (in_array($cityName, $universityCities)) {
            return true;
        }

        // Heurystyka: miasta >50k mieszka≈Ñc√≥w czƒôsto majƒÖ jakie≈õ uczelnie
        if ($population > 50000) {
            return true;
        }

        return false;
    }

    /**
     * Sprawdza czy miasto jest miejscem turystycznym.
     *
     * Wykorzystuje rozszerzonƒÖ listƒô destynacji turystycznych z pliku konfiguracyjnego.
     * Lista zawiera:
     * - Miasta historyczne i kulturowe
     * - Kurorty nadmorskie (Ba≈Çtyk)
     * - Kurorty g√≥rskie (Tatry, Sudety, Beskidy)
     * - Miejsca pielgrzymkowe
     * - Uzdrowiska
     * - Regiony jezior
     *
     * @param  string  $cityName  Nazwa miasta
     */
    private function isTouristDestination(string $cityName): bool
    {
        // Pobierz listƒô destynacji turystycznych z konfiguracji
        $touristDestinations = config('city_characteristics.tourist_destinations', []);

        return in_array($cityName, $touristDestinations);
    }

    /**
     * Sprawdza czy miasto jest centrum dojazdowym.
     *
     * Wykorzystuje rozszerzonƒÖ listƒô centr√≥w dojazdowych z pliku konfiguracyjnego.
     * Lista zawiera:
     * - Stolice wojew√≥dztw
     * - Du≈ºe miasta >100k mieszka≈Ñc√≥w
     * - Wa≈ºne centra przemys≈Çowe i biznesowe
     *
     * @param  string  $cityName  Nazwa miasta
     * @param  int  $population  Populacja
     */
    private function isCommuterHub(string $cityName, int $population): bool
    {
        // Pobierz listƒô centr√≥w dojazdowych z konfiguracji
        $commuterHubs = config('city_characteristics.commuter_hubs', []);

        // Je≈õli miasto jest na li≈õcie centr√≥w dojazdowych
        if (in_array($cityName, $commuterHubs)) {
            return true;
        }

        // Heurystyka: miasta >100k sƒÖ czƒôsto centrami dojazdowymi
        if ($population > 100000) {
            return true;
        }

        return false;
    }

    /**
     * Stosuje wsp√≥≈Çczynniki korekcyjne do populacji z grid√≥w.
     *
     * @param  int  $gridPopulation  Populacja z grid√≥w (G)
     * @param  array  $context  Kontekst lokalizacji
     * @return float Skorygowana populacja
     */
    private function applyCorrectionCoefficients(int $gridPopulation, array $context): float
    {
        // Pobierz wsp√≥≈Çczynniki dla kategorii miasta
        $coefficient = PopulationCoefficient::forCategory($context['category']);

        if (! $coefficient) {
            // Fallback - brak korekty je≈õli nie znaleziono wsp√≥≈Çczynnik√≥w
            Log::warning('Nie znaleziono wsp√≥≈Çczynnik√≥w dla kategorii', [
                'category' => $context['category'],
            ]);

            return $gridPopulation;
        }

        // Oblicz ca≈ÇkowitƒÖ korektƒô u≈ºywajƒÖc modelu
        $totalCorrectionFactor = $coefficient->calculateTotalCorrection($context);

        // Zastosuj korektƒô: corrected = G √ó total_correction_factor
        $correctedPopulation = $gridPopulation * $totalCorrectionFactor;

        Log::debug('Zastosowano wsp√≥≈Çczynniki korekcyjne', [
            'grid_population' => $gridPopulation,
            'category' => $context['category'],
            'k_base' => $coefficient->getAverageKBase(),
            'total_correction_factor' => round($totalCorrectionFactor, 4),
            'corrected_population' => round($correctedPopulation),
            'context' => $context,
        ]);

        return $correctedPopulation;
    }

    /**
     * Estymacja bazujƒÖca tylko na promieniu (fallback).
     *
     * U≈ºywana gdy brak danych gridowych lub wystƒÖpi≈Ç b≈ÇƒÖd.
     * Opiera siƒô na ≈õredniej gƒôsto≈õci zaludnienia Polski.
     *
     * @param  int  $radiusKm  Promie≈Ñ w kilometrach
     * @return int Szacowana liczba klient√≥w
     */
    private function estimateByRadius(int $radiusKm): int
    {
        // Przybli≈ºenie bazujƒÖce na ≈õredniej gƒôsto≈õci zaludnienia Polski (123 os/km¬≤)
        $averageDensity = 123;
        $area = pi() * pow($radiusKm, 2);
        $population = $area * $averageDensity;

        $petOwnershipRate = 0.37;
        $careSeekingRate = 0.25;

        Log::info('U≈ºyto fallback estymacji na podstawie ≈õredniej gƒôsto≈õci', [
            'radius_km' => $radiusKm,
            'area_km2' => round($area, 2),
            'estimated_population' => round($population),
            'potential_clients' => round($population * $petOwnershipRate * $careSeekingRate),
        ]);

        return max(50, round($population * $petOwnershipRate * $careSeekingRate));
    }
}
